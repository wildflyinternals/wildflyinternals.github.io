<p>We usually know the Fibonacci sequence generator for learning the recursive algorithm. In this article, I’d like to introduce to you a non-recursive implementation.</p>

<p>Here is the recursive version of the Fibonacci sequence generator we usually learn from the text book<sup id="fnref:fibrec"><a href="#fn:fibrec" class="footnote">1</a></sup>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>The disadvantage of the above implementation is that the stack memory usage will increase exponentially as the argument <code class="highlighter-rouge">n</code> increases. In addition, this recursion is not a tail-recursion<sup id="fnref:tail"><a href="#fn:tail" class="footnote">2</a></sup>, so it can’t be optimized easily by compiler.</p>

<p>Actually we can use loop instead of recursion to implement the fibonacci sequence more efficiently. Here is the one I wrote for example:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">nonrecursiveFibonacci</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="mi">2</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// for n == 2</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span> <span class="c1">// using `a` for temporary storage</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">sum</span><span class="o">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>As the codes shown above, I used a loop and some fine-grained boundary conditions to replace the recursion. In this way we totally eliminate the exponentially grown stack memory usages of the recursive version of the implementation. Now let’s write some codes for benchmark:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
<span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="o">(</span><span class="mi">40</span><span class="o">);</span>
<span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Time consumed by `fibonacci` method:"</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">));</span>
</code></pre>
</div>

<p>And this is for the non-recursive implementation benchmark:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">nonrecursiveFibonacci</span><span class="o">(</span><span class="mi">40</span><span class="o">);</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Time consumed by `nonrecursiveFibonacci` method:"</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">));</span>
</code></pre>
</div>

<p>As the codes shown above, we used two different versions of implementations to calculate the 40th fibonacci number. And here’s the running result:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>result: 165580141
Time consumed by `fibonacci` method:756
</code></pre>
</div>

<p>Here’s the result for the non-recursive implementation:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>result: 165580141
Time consumed by `nonrecursiveFibonacci` method:0
</code></pre>
</div>

<p>We can see the recursive implementation used 756 milliseconds to complete the calculation, and the time used by the non-recursive implementation can be neglected at millisecond level. In addition, the bigger the fibonacci number we want to calculate, the more performance difference between two implementations we’ll get. More seriously, the recursive version will finally fail as the argument <code class="highlighter-rouge">n</code> grows, because it will throw stack memory overflow exception for its exponentially grown stack memory usage.</p>

<p>In conclusion, though the recursive implementation is clean in design, but sometimes it’s not as efficient as the loop alternative. From the practical perspective, we should fine-tune our implementation to maximize the performance.</p>

<h3 id="references"><em>References</em></h3>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:fibrec">
      <p><a href="http://introcs.cs.princeton.edu/java/23recursion/Fibonacci.java.html">http://introcs.cs.princeton.edu.</a>&nbsp;<a href="#fnref:fibrec" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:tail">
      <p><a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org.</a>&nbsp;<a href="#fnref:tail" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
