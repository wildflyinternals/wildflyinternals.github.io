<p>In this article I’d like to show you a java implementation of Dijkstra’s Algorithm I’ve written.</p>

<p>I’m reading the book <em>Grokking Algorithm</em><sup id="fnref:grok"><a href="#fn:grok" class="footnote">1</a></sup> recently, and it introduces <em>Dijkstra’s Algorithm</em> in chapter 7. Here is a java implementation I’ve written:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="cm">/**
 * Created by weli on 26/02/2017.
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Graph</span> <span class="o">{</span>

    <span class="kd">class</span> <span class="nc">Edge</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">String</span> <span class="n">from</span><span class="o">;</span>
        <span class="kd">private</span> <span class="n">String</span> <span class="n">to</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">weight</span><span class="o">;</span>

        <span class="kd">public</span> <span class="n">String</span> <span class="nf">getFrom</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">from</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="n">String</span> <span class="nf">getTo</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">to</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getWeight</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">weight</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nf">Edge</span><span class="o">(</span><span class="n">String</span> <span class="n">from</span><span class="o">,</span> <span class="n">String</span> <span class="n">to</span><span class="o">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">from</span> <span class="o">=</span> <span class="n">from</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">to</span> <span class="o">=</span> <span class="n">to</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">"{"</span> <span class="o">+</span> <span class="n">from</span> <span class="o">+</span> <span class="s">"-&gt;"</span> <span class="o">+</span> <span class="n">to</span> <span class="o">+</span> <span class="s">" / "</span> <span class="o">+</span> <span class="n">weight</span> <span class="o">+</span> <span class="s">"}"</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">edges</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span> <span class="c1">// to -&gt; from</span>
    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">costs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">processed</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="n">start</span> <span class="o">=</span> <span class="s">"start"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">fin</span> <span class="o">=</span> <span class="s">"fin"</span><span class="o">;</span>

    <span class="o">{</span>
        <span class="n">processed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
        <span class="n">processed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">fin</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getStart</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">start</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getFin</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">fin</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="n">String</span> <span class="n">from</span><span class="o">,</span> <span class="n">String</span> <span class="n">to</span><span class="o">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">edges</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Edge</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">weight</span><span class="o">));</span>
        <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">from</span><span class="o">);</span>
        <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">from</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">start</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">costs</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="n">weight</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">costs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">to</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">costs</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="nf">nextCheapestNode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nodes</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">processed</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="c1">// all nodes are processed</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">cheapest</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">cheapestNode</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cost</span> <span class="o">:</span> <span class="n">costs</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Updated cost:"</span> <span class="o">+</span> <span class="n">cost</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cost</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">cheapest</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">processed</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">cost</span><span class="o">.</span><span class="na">getKey</span><span class="o">()))</span> <span class="o">{</span>
                <span class="n">cheapest</span> <span class="o">=</span> <span class="n">cost</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
                <span class="n">cheapestNode</span> <span class="o">=</span> <span class="n">cost</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"next cheapest: "</span> <span class="o">+</span> <span class="n">cheapestNode</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cheapestNode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dijkstra</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Initial costs: "</span> <span class="o">+</span> <span class="n">costs</span><span class="o">);</span>

        <span class="n">String</span> <span class="n">node</span> <span class="o">=</span> <span class="n">nextCheapestNode</span><span class="o">();</span>

        <span class="n">path</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">start</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">costs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="n">Set</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">findNeighbors</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">neighbors</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">newCost</span> <span class="o">=</span> <span class="n">cost</span> <span class="o">+</span> <span class="n">neighbor</span><span class="o">.</span><span class="na">getWeight</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">costs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">neighbor</span><span class="o">.</span><span class="na">getTo</span><span class="o">())</span> <span class="o">&gt;</span> <span class="n">newCost</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">costs</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">neighbor</span><span class="o">.</span><span class="na">getTo</span><span class="o">(),</span> <span class="n">newCost</span><span class="o">);</span>
                    <span class="n">path</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">neighbor</span><span class="o">.</span><span class="na">getTo</span><span class="o">(),</span> <span class="n">neighbor</span><span class="o">.</span><span class="na">getFrom</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">processed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">nextCheapestNode</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="nf">generatePath</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">StringBuffer</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuffer</span><span class="o">();</span>
        <span class="n">String</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">path</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getKey</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">fin</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getKey</span><span class="o">()).</span><span class="na">append</span><span class="o">(</span><span class="s">" &lt;- "</span><span class="o">);</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">path</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getKey</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">next</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getKey</span><span class="o">()).</span><span class="na">append</span><span class="o">(</span><span class="s">" &lt;- "</span><span class="o">);</span>
                    <span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">start</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
                        <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">findNeighbors</span><span class="o">(</span><span class="n">String</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Set</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">edge</span><span class="o">.</span><span class="na">getFrom</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">edge</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">neighbors</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Graph{"</span> <span class="o">+</span>
                <span class="s">"edges="</span> <span class="o">+</span> <span class="n">edges</span> <span class="o">+</span>
                <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="nf">getPath</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">path</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="n">Graph</span> <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Graph</span><span class="o">();</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"start"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"start"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"c"</span><span class="o">,</span> <span class="s">"fin"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="s">"fin"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g</span><span class="o">);</span>

        <span class="n">g</span><span class="o">.</span><span class="na">dijkstra</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g</span><span class="o">.</span><span class="na">getPath</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g</span><span class="o">.</span><span class="na">generatePath</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>I’ll introduce the above implementation in this article. Firstly, the usage is like this:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="n">Graph</span> <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Graph</span><span class="o">();</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"start"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"start"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"c"</span><span class="o">,</span> <span class="s">"fin"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="s">"fin"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g</span><span class="o">);</span>

        <span class="n">g</span><span class="o">.</span><span class="na">dijkstra</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g</span><span class="o">.</span><span class="na">getPath</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g</span><span class="o">.</span><span class="na">generatePath</span><span class="o">());</span>
<span class="o">}</span>
</code></pre>
</div>

<p>The above code created a <code class="highlighter-rouge">Graph</code> class, and added <em>edges</em> into the <em>graph</em>, and then the <code class="highlighter-rouge">dijkstra()</code> method is executed to calculate the <em>cheapest path</em>. Here is the execution result:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Graph{edges=[{start-&gt;a / 1}, {start-&gt;b / 1}, {a-&gt;b / 1}, {b-&gt;c / 1}, {a-&gt;c / 1}, {c-&gt;fin / 1}, {b-&gt;fin / 1}]}
Initial costs: {a=1, b=1, c=2147483647, fin=2147483647}
Updated cost:a=1
Updated cost:b=1
Updated cost:c=2147483647
Updated cost:fin=2147483647
next cheapest: b
Updated cost:a=1
Updated cost:b=1
Updated cost:c=2
Updated cost:fin=2
next cheapest: a
Updated cost:a=1
Updated cost:b=1
Updated cost:c=2
Updated cost:fin=2
next cheapest: c
{b=start, c=b, fin=b}
fin &lt;- b &lt;- start
</code></pre>
</div>

<p>We can see how the path costs are updated in each iteration, and how the final path is calculated at last. Here is the class diagram:</p>

<p><img src="/assets/dig-class.png" alt="Class Diagram" /></p>

<p>The <code class="highlighter-rouge">Graph</code> class is to store the structure <em>DAG</em>, of which the full name is <em>Directed Acyclic Graph</em>. The <code class="highlighter-rouge">Graph</code> contains a lot of <em>edges</em>, so the <code class="highlighter-rouge">Edge</code> class is to represent the structure.</p>

<p>Here are the attributes in <code class="highlighter-rouge">Edge</code> class:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Edge</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">from</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">to</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">weight</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">from</code> and <code class="highlighter-rouge">to</code> are two nodes of connected by the edge. We use <code class="highlighter-rouge">String</code> as node class. This is okay because we don’t allow different nodes to have same name. The <code class="highlighter-rouge">weight</code> attribute is straight-forward and it stores the weight of this edge for calculation. Because <code class="highlighter-rouge">Graph</code> contains many <em>edges</em>, so in <code class="highlighter-rouge">Graph</code> class, we store these edges like this:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">edges</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre>
</div>

<p>We also need to store all the <em>nodes</em> in graph for later calculation:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>
</code></pre>
</div>

<p>Please note we use <code class="highlighter-rouge">Set&lt;String&gt;</code> to store the <code class="highlighter-rouge">nodes</code>, because <code class="highlighter-rouge">Set</code> type will not store entries with same value. This can ensure no duplicated nodes will appear in the data structure. The next important data structure is the <em>cost table</em>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">costs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</code></pre>
</div>

<p>This table stores the <em>weight sum</em> from the start point to the target node. During calculation process, this table will be keep updated.</p>

<p>Another important thing is that we use <code class="highlighter-rouge">Map&lt;String, Integer&gt;</code> type to store the <em>node &lt;-&gt; weight sum</em> pair，because the <code class="highlighter-rouge">Map</code> type is simliar to the <code class="highlighter-rouge">Set</code> type, it won’t accept duplicate key value, which means it won’t contain multiple entries for same <code class="highlighter-rouge">node</code>.</p>

<p>If we put a <em>String &lt;-&gt; Integer</em> pair with an existing <code class="highlighter-rouge">String</code> value in <code class="highlighter-rouge">Map</code>, it will just update the existing entry. That is just what we need: to update the <em>node &lt;-&gt; weight sum</em> entry with new value.</p>

<p>We also need to mark the <em>start node</em> and the <em>end node</em> of a graph, and here are the relative attributes in <code class="highlighter-rouge">Graph</code> class:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">String</span> <span class="n">start</span> <span class="o">=</span> <span class="s">"start"</span><span class="o">;</span>
<span class="kd">private</span> <span class="n">String</span> <span class="n">fin</span> <span class="o">=</span> <span class="s">"fin"</span><span class="o">;</span>
</code></pre>
</div>

<p>We can compare the node name in calculation process to check if it is start or end point. Now let us check the methods in <code class="highlighter-rouge">Graph</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="n">String</span> <span class="n">from</span><span class="o">,</span> <span class="n">String</span> <span class="n">to</span><span class="o">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">edges</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Edge</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">weight</span><span class="o">));</span>
    <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">from</span><span class="o">);</span>
    <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">from</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">start</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">costs</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="n">weight</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">costs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">to</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">costs</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>The purpose of above method is to add an <em>edge</em> into <em>graph</em>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">edges</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Edge</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">weight</span><span class="o">));</span>
</code></pre>
</div>

<p>And also add the two nodes of the edge into <code class="highlighter-rouge">nodes</code> set:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">from</span><span class="o">);</span>
<span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</code></pre>
</div>

<p>We do not need to worry that we will add duplicate nodes into <code class="highlighter-rouge">nodes</code> set, because the type of <code class="highlighter-rouge">nodes</code> is <code class="highlighter-rouge">Set</code>, it does not contain duplicate entries with same value. Adding the <code class="highlighter-rouge">String</code> with same value will just overwrite the existing one. The next important task of <code class="highlighter-rouge">addEdge</code> is to update the <code class="highlighter-rouge">costs</code> table:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">from</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">start</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">costs</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="n">weight</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">costs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">to</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">costs</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>We need to consider two conditions as shown above: Firstly, we need to check if the added edge is connected with start point. If so, we need to save the true weight into <code class="highlighter-rouge">costs</code> table, because they are initial edges need to be calculated by the algorithm.</p>

<p>Otherwise, we just use <code class="highlighter-rouge">Integer.MAX_VALUE</code> as the weight of the edge, because we do not want the algorithm to pick up these edges in initial calculation. During the calculation process, the true costs of these edges can be fetched from the <code class="highlighter-rouge">weight</code> attribute of <code class="highlighter-rouge">Edge</code> class later for calculation. Please note this condition:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">costs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">to</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</code></pre>
</div>

<p>We need to check whether <code class="highlighter-rouge">costs</code> table contains the <code class="highlighter-rouge">to</code> node of the added edge, in case the weight value is overwrittee. This is important because the node connecting with start node may be part of multiple edges, and the edge that is not connecting with start node may overwrite the weight value of this node. Here is the diagram for example:</p>

<p><img src="/assets/dij01.jpg" alt="Graph" /></p>

<p>As the diagram shown above,  <em>b</em> is connected with both <em>start</em> and <em>c</em>, so it belongs to two edges: <em>start -&gt; b</em> and <em>b -&gt; c</em>. In this case, if we add edge <em>start -&gt; b</em> firstly, the cost of b will be 1 in <code class="highlighter-rouge">costs</code> table.</p>

<p>But if we add edge <em>b -&gt; c</em> later, the cost of b will be updated with value <code class="highlighter-rouge">Integer.MAX_VALUE</code> if we don’t check the existing value in <code class="highlighter-rouge">costs</code> table, and then the algorithm will fail because the initial weight of <em>b</em>, which is connected with start node, is not correct. Now let’s see <code class="highlighter-rouge">nextCheapestNode()</code> method：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">String</span> <span class="nf">nextCheapestNode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nodes</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">processed</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="c1">// all nodes are processed</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">cheapest</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">cheapestNode</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cost</span> <span class="o">:</span> <span class="n">costs</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Updated cost:"</span> <span class="o">+</span> <span class="n">cost</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cost</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">cheapest</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">processed</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">cost</span><span class="o">.</span><span class="na">getKey</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">cheapest</span> <span class="o">=</span> <span class="n">cost</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="n">cheapestNode</span> <span class="o">=</span> <span class="n">cost</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"next cheapest: "</span> <span class="o">+</span> <span class="n">cheapestNode</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">cheapestNode</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>This method is to find the next cheapest node that is not processed yet. Here is the important part:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">cost</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">cheapest</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">processed</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">cost</span><span class="o">.</span><span class="na">getKey</span><span class="o">()))</span>
</code></pre>
</div>

<p>We used a <code class="highlighter-rouge">processed</code> list to store the nodes that have been processed in <code class="highlighter-rouge">Graph</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">processed</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre>
</div>

<p>After all the nodes are calculated, then all the nodes should be in <code class="highlighter-rouge">processed</code> list. Here is the end condition:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">nodes</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">processed</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="c1">// all nodes are processed</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</code></pre>
</div>

<p>We need to initialize the <code class="highlighter-rouge">processed</code> list in <code class="highlighter-rouge">Graph</code> like this:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">{</span>
    <span class="n">processed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
    <span class="n">processed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">fin</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Because start and end nodes will never be calculated and they are already processed. Now let us check the entry function:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">dijkstra</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Initial costs: "</span> <span class="o">+</span> <span class="n">costs</span><span class="o">);</span>

    <span class="n">String</span> <span class="n">node</span> <span class="o">=</span> <span class="n">nextCheapestNode</span><span class="o">();</span>

    <span class="n">path</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">start</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">costs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="n">Set</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">findNeighbors</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">neighbors</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">newCost</span> <span class="o">=</span> <span class="n">cost</span> <span class="o">+</span> <span class="n">neighbor</span><span class="o">.</span><span class="na">getWeight</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">costs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">neighbor</span><span class="o">.</span><span class="na">getTo</span><span class="o">())</span> <span class="o">&gt;</span> <span class="n">newCost</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">costs</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">neighbor</span><span class="o">.</span><span class="na">getTo</span><span class="o">(),</span> <span class="n">newCost</span><span class="o">);</span>
                <span class="n">path</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">neighbor</span><span class="o">.</span><span class="na">getTo</span><span class="o">(),</span> <span class="n">neighbor</span><span class="o">.</span><span class="na">getFrom</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">processed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">nextCheapestNode</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>This function will find the first node to calculate:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">node</span> <span class="o">=</span> <span class="n">nextCheapestNode</span><span class="o">();</span>
</code></pre>
</div>

<p>Then it will enter the calculation loop to calculate all the nodes in graph according to the algorithm:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</code></pre>
</div>

<p>In the loop, the function will find the next cheapest node, calculate the path weight, and update the <code class="highlighter-rouge">costs</code> table. In additon, it will generate the <code class="highlighter-rouge">path</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span> <span class="c1">// to -&gt; from</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">path</code> is the <code class="highlighter-rouge">parent</code> data structure in the book, it contains the <em>to -&gt; from</em> data pair. We can use this data structure to generate a complete path from end to start.</p>

<p>Why it’s from end to start? It’s determined by the algorithm calculation process, we may have some orphan paths in above data structure as the result of updated costs calculation, but we can always find a sole path from end to the start.</p>

<p>During the calculation process, if it finds a cheaper path, the <code class="highlighter-rouge">from</code> of a <code class="highlighter-rouge">to</code> will be updated, so we use <code class="highlighter-rouge">to</code> as <em>key</em> and <code class="highlighter-rouge">from</code> as <em>value</em>. In this way, where is the <code class="highlighter-rouge">to</code> from is always unique, and some <em>to -&gt; from</em> entries will become orphan and useless. But that doesn’t matter, because we get a unique <em>to &lt;- from &lt;- to &lt;- from</em> path. We can clear <code class="highlighter-rouge">path</code> data easily. Finally let’s recheck the usage of the codes:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">Graph</span> <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Graph</span><span class="o">();</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"start"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"start"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"c"</span><span class="o">,</span> <span class="s">"fin"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="s">"fin"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</code></pre>
</div>

<p>The above codes will create this graph:</p>

<p><img src="/assets/dij02.jpg" alt="Graph" /></p>

<p>Then we execute the algorithm:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">g</span><span class="o">.</span><span class="na">dijkstra</span><span class="o">();</span>
</code></pre>
</div>

<p>And finally we print out the path:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g</span><span class="o">.</span><span class="na">generatePath</span><span class="o">());</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">generatePath()</code> is to print the path from <em>end</em> to <em>start</em> by using <code class="highlighter-rouge">path</code> data:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">String</span> <span class="nf">generatePath</span><span class="o">()</span> <span class="o">{</span>
	<span class="n">StringBuffer</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuffer</span><span class="o">();</span>
	<span class="n">String</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">path</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
	    <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getKey</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">fin</span><span class="o">))</span> <span class="o">{</span>
	        <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getKey</span><span class="o">()).</span><span class="na">append</span><span class="o">(</span><span class="s">" &lt;- "</span><span class="o">);</span>
	        <span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
	    <span class="o">}</span>
	<span class="o">}</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
	    <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">path</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
	        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getKey</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">next</span><span class="o">))</span> <span class="o">{</span>
	            <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getKey</span><span class="o">()).</span><span class="na">append</span><span class="o">(</span><span class="s">" &lt;- "</span><span class="o">);</span>
	            <span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
	            <span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">start</span><span class="o">))</span> <span class="o">{</span>
	                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
	                <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	            <span class="o">}</span>
	        <span class="o">}</span>
	    <span class="o">}</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre>
</div>

<p>It will find the end node firstly, and use it as the initial <code class="highlighter-rouge">to</code>, then it will find its <code class="highlighter-rouge">from</code> in <code class="highlighter-rouge">path</code> data, and do this in a loop and it reaches the start point. Let’s see the result:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Updated cost:fin=2
fin &lt;- b &lt;- start
</code></pre>
</div>

<p>The cheapest path of above graph is <em>fin &lt;- b &lt;- start</em>. Now let’s try to change the weight of some nodes:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"start"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"start"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"c"</span><span class="o">,</span> <span class="s">"fin"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">g</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="s">"fin"</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
</code></pre>
</div>

<p>The graph becomes:</p>

<p><img src="/assets/dij03.jpg" alt="Graph" /></p>

<p>We can see the weight of <em>start -&gt; b</em> and <em>b -&gt; c</em> have been increased. Now let’s rerun the algorithm:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Updated cost:fin=3
fin &lt;- c &lt;- a &lt;- start
</code></pre>
</div>

<p>We can see the cheapest path has been changed accordingly. Dijkstra’s Algorithm is an interesting algorithm and worth studying.</p>

<h3 id="references"><em>References</em></h3>

<hr />
<div class="footnotes">
  <ol>
    <li id="fn:grok">
      <p>Bhargava, Aditya Y.. <em>Grokking Algorithms: An Illustrated Guide for Programmers and Other Curious People.</em> Shelter Island: Manning, 2016. Print.&nbsp;<a href="#fnref:grok" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
